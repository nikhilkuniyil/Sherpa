#!/usr/bin/env python3
"""
Skeleton generator for tutorial mode.
Generates complete implementation files with TODOs for users to fill in.
"""

import os
import re
from typing import Optional, Dict
from datetime import datetime


# Prompt template for generating implementation skeletons
SKELETON_GENERATION_PROMPT = """Generate a complete Python implementation skeleton for {topic}.

Context about the paper/technique:
{paper_context}

Requirements:
1. Create a COMPLETE, runnable Python file structure
2. Include all necessary imports (torch, transformers, etc.)
3. Add 4-7 TODO comments for the key implementation steps
4. Each TODO should:
   - Have a clear number (TODO 1, TODO 2, etc.)
   - State the GOAL of what needs to be implemented
   - Include a HINT that guides without giving the answer
   - Use 'pass' as placeholder where code should go
5. The skeleton should be educational - TODOs should build on each other
6. Include docstrings explaining what each method does
7. Add example usage at the bottom (commented out)

TODO Format (follow exactly):
```
# TODO 1: [Brief title]
# Goal: [What this code should accomplish]
# Hint: [Conceptual hint without giving away the answer]
pass
```

The implementation should cover:
- Class initialization / setup
- Core algorithm logic (the key mathematical operations)
- Training/inference loop components
- Any helper functions needed

Return ONLY the Python code, no markdown code blocks or explanations.
Start with the imports and end with the example usage."""


class SkeletonGenerator:
    """Generates implementation skeletons using LLM"""

    def __init__(self, llm_client, paper_context: str = ""):
        self.llm = llm_client
        self.paper_context = paper_context

    def generate(self, topic: str) -> str:
        """
        Generate a complete implementation skeleton for a topic.

        Args:
            topic: The topic/paper to implement (e.g., "DPO", "ORPO")

        Returns:
            Complete Python code skeleton with TODOs
        """
        if not self.llm:
            return self._get_fallback_skeleton(topic)

        prompt = SKELETON_GENERATION_PROMPT.format(
            topic=topic,
            paper_context=self.paper_context[:3000] if self.paper_context else f"Implement {topic}"
        )

        try:
            response = self.llm.messages.create(
                model="default",
                max_tokens=4000,
                messages=[{"role": "user", "content": prompt}]
            )

            code = response.content[0].text

            # Clean up response - remove markdown code blocks if present
            code = self._clean_code(code)

            # Add header
            code = self._add_header(topic, code)

            return code

        except Exception as e:
            print(f"Warning: Failed to generate skeleton: {e}")
            return self._get_fallback_skeleton(topic)

    def _clean_code(self, code: str) -> str:
        """Remove markdown formatting if present"""
        # Remove ```python and ``` blocks
        code = re.sub(r'^```python\s*\n', '', code)
        code = re.sub(r'^```\s*\n', '', code)
        code = re.sub(r'\n```\s*$', '', code)
        code = re.sub(r'^```\s*$', '', code, flags=re.MULTILINE)
        return code.strip()

    def _add_header(self, topic: str, code: str) -> str:
        """Add a header to the generated code"""
        header = f'''#!/usr/bin/env python3
"""
{topic} Implementation - Tutorial Mode
Generated by Sherpa on {datetime.now().strftime("%Y-%m-%d %H:%M")}

Instructions:
1. Complete the TODOs in order (TODO 1, TODO 2, etc.)
2. Save the file after completing each TODO
3. Sherpa will automatically review your work and provide feedback
4. Use 'hint' in the terminal if you get stuck

Good luck!
"""

'''
        # Don't duplicate if code already has a shebang
        if code.startswith('#!/'):
            return code

        return header + code

    def _get_fallback_skeleton(self, topic: str) -> str:
        """Return a basic fallback skeleton if LLM is unavailable"""
        return f'''#!/usr/bin/env python3
"""
{topic} Implementation - Tutorial Mode
Generated by Sherpa

Complete the TODOs below. Save the file to get feedback.
"""

import torch
import torch.nn as nn
import torch.nn.functional as F


class {topic.replace(" ", "")}Implementation:
    """
    Implementation of {topic}

    Complete the TODOs below to build your implementation.
    """

    def __init__(self):
        # TODO 1: Initialize the model and any required components
        # Goal: Set up the necessary instance variables
        # Hint: Think about what state this class needs to maintain
        pass

    def forward(self, inputs):
        # TODO 2: Implement the forward pass
        # Goal: Process the inputs through your model
        # Hint: Consider what transformations are needed
        pass

    def compute_loss(self, outputs, targets):
        # TODO 3: Implement the loss function
        # Goal: Calculate the training loss
        # Hint: What loss function is appropriate for this task?
        pass

    def train_step(self, batch):
        # TODO 4: Implement a single training step
        # Goal: Process one batch and update the model
        # Hint: Forward pass -> loss -> backward pass -> optimizer step
        pass


# Example usage (uncomment to test):
# model = {topic.replace(" ", "")}Implementation()
# output = model.forward(sample_input)
# loss = model.compute_loss(output, target)
'''

    def write_to_file(self, topic: str, directory: str = ".") -> str:
        """
        Generate skeleton and write to file.

        Args:
            topic: Topic to implement
            directory: Directory to write the file to

        Returns:
            Path to the created file
        """
        # Generate the skeleton
        skeleton = self.generate(topic)

        # Create filename
        safe_topic = re.sub(r'[^\w\s-]', '', topic.lower())
        safe_topic = re.sub(r'[-\s]+', '_', safe_topic)
        filename = f"{safe_topic}_implementation.py"
        filepath = os.path.join(directory, filename)

        # Write to file
        with open(filepath, 'w') as f:
            f.write(skeleton)

        return filepath

    def count_todos(self, code: str) -> int:
        """Count the number of TODOs in the code"""
        return len(re.findall(r'#\s*TODO\s*\d+', code, re.IGNORECASE))
